{"version":3,"sources":["gluon-router.js"],"names":["routingEnabled","routeChangeCallbacks","onRouteChange","window","addEventListener","notifyRouteChange","document","body","globalClickHandler","push","defaultPrevented","getSameOriginLinkHref","preventDefault","location","href","history","pushState","dispatchEvent","Event","button","metaKey","ctrlKey","path","composedPath","length","tagName","target","top","resolveURL","baseURI","origin","protocol","host","pathname","search","hash","forEach","currentPath","currentQuery","currentHash","decodeURIComponent","slice","workingURL","resolveDoc","URL","implementation","createHTMLDocument","base","createElement","head","appendChild","anchor"],"mappings":"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","file":"gluon-router.js","sourcesContent":["let routingEnabled = false;\nconst routeChangeCallbacks = [];\n\nexport const onRouteChange = callback => {\n  if (!routingEnabled) {\n    // Set up listeners for route changes\n    window.addEventListener('hashchange', notifyRouteChange);\n    window.addEventListener('location-changed', notifyRouteChange);\n    window.addEventListener('popstate', notifyRouteChange);\n    document.body.addEventListener('click', globalClickHandler);\n    routingEnabled = true;\n  }\n\n  routeChangeCallbacks.push(callback);\n};\n\nconst globalClickHandler = event => {\n  // If another event handler has stopped this event then there's nothing\n  // for us to do. This can happen e.g. when there are multiple\n  // iron-location elements in a page.\n  if (event.defaultPrevented) {\n    return;\n  }\n\n  // Get the href if the target of this click was a link\n  const href = getSameOriginLinkHref(event);\n\n  // If no link was clicked, there's nothing to do\n  if (!href) {\n    return;\n  }\n\n  // Stop the browser from navigating\n  event.preventDefault();\n\n  // If the navigation is to the current page we shouldn't add a history\n  // entry or fire a change event.\n  if (href === window.location.href) {\n    return;\n  }\n\n  window.history.pushState({}, '', href);\n  window.dispatchEvent(new Event('location-changed'));\n};\n\nconst getSameOriginLinkHref = event => {\n  // We only care about left-clicks.\n  if (event.button !== 0) {\n    return null;\n  }\n\n  // We don't want modified clicks, where the intent is to open the page\n  // in a new tab.\n  if (event.metaKey || event.ctrlKey) {\n    return null;\n  }\n\n  // Find the first link in the event path\n  const eventPath = event.path || (event.composedPath && event.composedPath());\n  let anchor = null;\n  for (var i = 0; i < eventPath.length; i++) {\n    var element = eventPath[i];\n    if (element.tagName === 'A' && element.href) {\n      anchor = element;\n      break;\n    }\n  }\n\n  // If there's no link there's nothing to do.\n  if (!anchor) {\n    return null;\n  }\n\n  // Target blank is a new tab, don't intercept.\n  if (anchor.target === '_blank') {\n    return null;\n  }\n\n  // If the link is for an existing parent frame, don't intercept.\n  if ((anchor.target === '_top' || anchor.target === '_parent') && window.top !== window) {\n    return null;\n  }\n\n  const href = anchor.href;\n  const url = resolveURL(href, document.baseURI);\n\n  // It only makes sense for us to intercept same-origin navigations.\n  // pushState/replaceState don't work with cross-origin links.\n  let urlOrigin;\n  if (url.origin) {\n    urlOrigin = url.origin;\n  } else {\n    urlOrigin = url.protocol + '//' + url.host;\n  }\n  if (urlOrigin !== window.location.origin) {\n    return null;\n  }\n\n  let normalizedHref = url.pathname + url.search + url.hash;\n  // pathname should start with '/', but may not if `new URL` is not supported\n  if (normalizedHref[0] !== '/') {\n    normalizedHref = '/' + normalizedHref;\n  }\n\n  // Need to use a full URL in case the containing page has a base URI.\n  return resolveURL(normalizedHref, window.location.href).href;\n};\n\nconst notifyRouteChange = () => {\n  routeChangeCallbacks.forEach(callback => callback(currentPath(), currentQuery(), currentHash()));\n};\n\nexport const currentPath = () => {\n  return window.decodeURIComponent(window.location.pathname);\n};\n\nexport const currentQuery = () => {\n  return window.location.search.slice(1);\n};\n\nexport const currentHash = () => {\n  return window.decodeURIComponent(window.location.hash.slice(1));\n};\n\n// Cache for resolveURL\nlet workingURL;\nlet resolveDoc;\n\n// Helper method to resolve a path to a full URL.\nexport const resolveURL = (path, base) => {\n  if (base === null) {\n    base = undefined;\n  }\n  // Feature detect URL\n  if (workingURL === undefined) {\n    workingURL = false;\n    try {\n      const u = new URL('b', 'http://a');\n      u.pathname = 'c%20d';\n      workingURL = u.href === 'http://a/c%20d';\n      workingURL = workingURL && new URL('http://a/?b c').href === 'http://a/?b%20c';\n    } catch (e) {\n      // silently fail\n    }\n  }\n\n  if (workingURL) {\n    return new URL(path, base);\n  }\n\n  // Fallback to creating an anchor into a disconnected document.\n  if (!resolveDoc) {\n    resolveDoc = document.implementation.createHTMLDocument('temp');\n    resolveDoc.base = resolveDoc.createElement('base');\n    resolveDoc.head.appendChild(resolveDoc.base);\n    resolveDoc.anchor = resolveDoc.createElement('a');\n  }\n  resolveDoc.base.href = base;\n  resolveDoc.anchor.href = path;\n  return resolveDoc.anchor;\n};\n"]}